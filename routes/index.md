Confoo Two-Factor Demo
======================
This Express route is where I've put in all the code for my little demonstration of authentication using Google Authenticator and a Yubikey. This is a literate coffee-script file, which is a new feature of coffee-script 1.5.0. This means that this document is written in Markdown, using the same convention of indentation for code. However, note that the indented code Is also executable, Exciting! This will allow me to document thought processes and pitfalls of this toy project.

Dependencies
---------
In order to communicate with Yubico's authentication server, you'll need to use the **http or https** module. Other than that, we'll be abstracting the HMAC SHA-1 hashing and use some conversion methods of **CryptoJS** to make things clearer. Lastly, we'll use **underscore** to make it easier to search in our in-memory user store, you normally wouldn't really need that.
    
```coffeescript
    https = require('https')
    base32 = require('base32')
    Crypto = (require 'cryptojs').Crypto
    _ = require 'underscore'

    module.exports = (app)->
```
    
Users
-----
Since we wanted to remove the complexity of managing a database of users, we just decided to use an array of user objects. This array is editable, as we'll see in the registration route, but will be wiped with each Express reboot. Note the **yubico_identity** and **googleCode** fields. The **yubico_identity** field is the static portion of the code generated by the yubikey device, and is used to map a user to a key. As of **googleCode**, it is a base32 encoded shared secret between the authenticator app (or service) and the user in this webapp.

```coffeescript
      @users = [
        {
          user: "admin"
          password: "password"
          yubico_identity: "ccccccbggtft"
          googleCode: "JBSWY3DPEHPK3PXP"
        },
        {
          user: "schmuck"
          password: "password"
          yubico_identity: "fifjgjgkhcha"
          googleCode: "JBSWY3DPEHPK3PXX"
        }
      ]
```

Routes
------
Here we have two simple routes to the index and register pages, they are simple jade pages, nothing awesome.

```coffeescript
      app.get '/', (req, res )->
        res.render 'index', { title: 'Confoo Demo' }

      app.get '/register', (req, res )->
        res.render 'register', { title: 'Confoo Demo' }
```

The **do_register** lets a user register to our webapp. Basically, we take the form data from the body and add a **user** object to our **users** collection. The two things to note are that we generate a new base32 secret to use for google authenticator in **generateBase32Code()** (more below) and we extract the identity from the code generated by the yubikey. Note that we also pass the code to our jade view. That'll allow us to render a scannable QR code for our user.

```coffeescript
      app.post '/do_register', (req, res )->
        #Save user, generate key
        code = generateBase32Code()
        user =
          user: req.body.user
          password: req.body.password
          yubico_identity: extractYubicoIdentity req.body.yubicode
          googleCode: code
        @users.push user
        res.render 'do_register', { title: 'Confoo Demo', user:user.user, code:user.googleCode }
```

Our **verify** route is where we really test out our two-factor strategies. First off, we do the usual:

```coffeescript
      app.post '/verify', (req, res )->
        #Check if user exists
        user =_.find @users, (user) ->
          user.user  is  req.body.user
        #Check if old style password works
        if user && user.password  is  req.body.password
```

At that point, we have roughly validated that the user exists, and that he's used the right password. We must now verify that the key entered is either a Yubico key or a Google code, and we call the appropriate verification code. Note that we check for a Yubico code by using a length range. The Yubiko secret part of the OTP is 32 characters long, and the identity can be up to 16 characters long. Keep in mind also that we do not validate the keyspace with regex, as Yubico uses a format called **modhex** to generate keys. This is due to their device actually behaving like keyboards, which can behave differently according to machine settings and locale. If we do detect a Yubico code, we check that the identity part matches what we saved in our user settings.

```coffeescript
          #Check if key format Yubikey or Google
          key = req.body.key
          if 32 <= key.length <= 48
            identity = extractYubicoIdentity key
            #Check to make sure identity matches
            if user.yubico_identity  is  identity
              #Call yubico HQ
              verifyYubicode key , user, res
            else
              res.render 'fail', {title: 'Confoo Demo' , reason: 'Unknown Yubico identity.' }
          else
            #Try to derive the same key with code and time
            otp = computeOTP(user.googleCode)
            if otp is key
              res.render 'authenticated', {title: 'Confoo Demo' , user: user.user }
            else
              res.render 'fail', {title: 'Confoo Demo' , reason: 'Bad Key.' }
        else
          res.render 'fail', {title: 'Confoo Demo' , reason: 'Wrong Username/Password' }
```

Yubico verification and utilities
-------------
First off, a little simple function to extract the Yubico public identity from a generated key. Granted, it's basically a one liner, but it helps understand the registration and verification flow to name it. 

```coffeescript
    extractYubicoIdentity = (code) ->
      #the key is always 32 chars, the rest is identity
      code.slice 0,-32
```

Alright, here's where the Yubico magic happens. First off, if you have an API Key,  configure your environment variables **YUBIKEY\_CLIENT** and **YUBIKEY\_ SECRET**. If you have a yubikey, you can get your client id and client secret from [the Yubico site](https://upgrade.yubico.com/getapikey/). Every response from the Yubico server is sent back with a signature hash made with their copy of the shared secret key for the corresponding id. This allows you to verify this signature by re-hashing the response and comparing the hashes (we'll see that below). We also generate a **nonce** to add to our request, which will be sent back to us by the Yubico server. We then make an https request to the yubico server.

```coffeescript
    verifyYubicode = (otp, user, response)->
      clientId = process.env['YUBIKEY_CLIENT'] || 1
      secretKey = process.env['YUBIKEY_SECRET']
      #You would probably use a better random here.
      nonce = Crypto.util.bytesToHex Crypto.util.randomBytes 20

      req = https.get "https://api2.yubico.com/wsapi/2.0/verify?id=#{clientId}&otp=#{otp}&nonce=#{nonce}", (res)->
        data = ""
        res.setEncoding('utf8')

        res.on 'data', (chunk) ->
          data = data + chunk
```

The Yubico server replies to our request with a few lines, containing a **hash**, a **status** for our OTP, the **otp** itself and the **nonce** we gave it at the time of the request. We then construct an easier to manipulate object and we check the following:
+ We make sure the **status** is **OK**
+ The **nonce** sent back by Yubico is the same we sent it
+ The **otp** sent back by Yubico is the same we sent it

If that's all right and we didn't set our **YUBIKEY\_SECRET**, then we're done!

```coffeescript
        res.on 'end', () ->
          lines = data.split "\n"
          result = {}
          #Create a friendlier object
          for line in lines
            line = line.split "="
            #We trim the end
            result[line[0]] = line[1]?.replace(/^\s+|\s+$/g, '')
          #restore stripped =
          result.h = result.h + "="
          #Check status
          if result.status  is  "OK"
            #Check nonce
            if result.nonce  is  nonce
              #Check same OTP
              if result.otp  is  otp
                #If we haven't changed our clientId we'll skip hashing
                if clientId  is  1 || !secretKey
                    console.log "Warning: No hash configuration"
                    response.render 'authenticated', {title: 'Confoo Demo' , user: user.user }
                else
```

If we have specified a specific secret key, we'll use HMAC-SHA1 using that key to generate a hash of the server reply. Note that the message to be hashed is the list of **alphabetically sorted** parameters (aside from **h**) and values sent back from the server, separated by **&** instead of new lines. We'll be using CryptoJS to assist us. The computed hash should be the same as the **h** parameter (in a Base64).
```coffeescript
                  #Combine all parameters except  hash, in a single string no new line
                  #Separate params with &, then HMAC-SHA1 it using private key
                  message = "nonce=#{result.nonce}&otp=#{result.otp}&sl=#{result.sl}&status=#{result.status}&t=#{result.t}"
                  key = Crypto.util.base64ToBytes secretKey
                  hmac = Crypto.HMAC(Crypto.SHA1, message, key, null)
                  computedHash = Crypto.util.hexToBytes hmac
                  computedHash = Crypto.util.bytesToBase64 computedHash
                  #Compare the hash
                  if result.h  is  computedHash
                    response.render 'authenticated', {title: 'Confoo Demo' , user: user.user }
                  else
                    response.render 'fail', {title: 'Confoo Demo' , reason: "Yubico responded with a bad signature hash, impersonator?" }
              else
                response.render 'fail', {title: 'Confoo Demo' , reason: "Yubico responded with a different otp, copy-paste attack?" }
            else
              response.render 'fail', {title: 'Confoo Demo' , reason: "Yubico responded with a different nonce, copy-paste attack?" }
          else
            response.render 'fail', {title: 'Confoo Demo' , reason: "Yubico responded with status: #{result.status}." }
            
        
      req.on 'error', (e)->
        console.log('problem with request: ' + e.message)
        response.render 'fail', {title: 'Confoo Demo' , reason: 'Unknown Yubico identity.' }
```

Below conversion and OTP code inspired by TOPT Draft http://tools.ietf.org/id/draft-mraihi-totp-timebased-06.html
And JS implementation at http://blog.tinisles.com/2011/10/google-authenticator-one-time-password-algorithm-in-javascript/
Provides a working example, will refactor for readability and eventually migrate components to external lib.

```coffeescript
    generateBase32Code = ()->
      #Granted, you'll want something a little more advanced than this
      base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
      key = ""
      for i in [1..16]
        key += base32chars.charAt Math.floor( Math.random() * (base32chars.length-1) )
      key
      
    dec2hex = (s) ->
      return (if s < 15.5 then '0' else '') + Math.round(s).toString(16)

    hex2dec = (s) ->
      return parseInt s, 16
```

A quick note about Base32, be aware that there's multiple implementations of it. The base32 encoding allows a human-readable representation of data. As such, characters that look alike such as **O** and **0** as well as **I** and **1** are avoided. In the case of Google Authenticator's shared secret, it uses the implementation found in *base32chars* (full alphabet and 234567). You can find more details in [RFC3548](http://tools.ietf.org/html/rfc3548#page-6)

```coffeescript
    base32tohex = (base32) ->
      base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
      bits = ""
      hex = ""

      for char, index in base32.split ''
        val = base32chars.indexOf(char.toUpperCase())
        bits += leftpad(val.toString(2), 5, '0')

      for char, index in bits.split ''
        if index%4 is 0 && index < bits.length - 1
          chunk = bits.substr(index, 4)
          hex = hex + parseInt(chunk, 2).toString(16)
      hex

    leftpad = (str, len, pad) ->
      if (len + 1 >= str.length)
        str = Array(len + 1 - str.length).join(pad) + str
      str
```

And here's the TOTP calculation used for Google Authenticator according to [RFC6238](http://tools.ietf.org/html/rfc6238) which is an extension to HOTP defined in [RFC4226](http://tools.ietf.org/html/rfc4226). 

```coffeescript
    computeOTP = (key)->
      delay = 30
      key = base32tohex key
      seconds = Math.round(new Date().getTime() / 1000.0)
      time = leftpad(dec2hex(Math.floor(seconds / delay)), 16, '0')
      bytesTime = Crypto.util.hexToBytes time
      bytesKey = Crypto.util.hexToBytes key
      hmac = Crypto.HMAC(Crypto.SHA1, bytesTime, bytesKey, null)
      offset = hex2dec(hmac.slice -1)
      otp = (hex2dec(hmac.substr(offset * 2, 8)) & hex2dec('7fffffff')) + ''
      otp = otp.slice -6
      otp
```
